---
layout: post
title:  "Minimoog VST - Comp Sound Final"
author: Mirea Klee
---

[see the code in action :)](https://miiklee.github.io/minimoog/)


#### Planning

Earlier on in this class we were assigned to make some kind of computer synthesizer in WebAudio. In the process of brainstorming for that project I decided to research the origins of synthesizers and came upon Bob Moog and the minimoog. Bob Moog is widely considered to be the father of synthesizers in music, and in particular he took his very popular Moog synthesizer and made the minimoog for popular consumption. He wanted to make synths more accessible to everyday musicians and musicians on the go, and he did just that, helping to transform the world of sound as we know it -- the moog synth was used by groups like the Beatles and ABBA. Anyways, I became obsessed and wanted to recreate it for public use online instead of having to spend a couple hundred dollars to buy the real thing (or $25 for the official minimoog app).

Once I decided to create the minimoog for my final project, I decided the first step was to map out what actually needed to be created. I turned to the[minimoog manual](https://api.moogmusic.com/sites/default/files/2018-01/Minimoog_Model_D_Manual.pdf) for very helpful info on what every aspect of the synth actually was. In particular they have a diagram which shows exactly how sound goes through the machine and is affected by each aspect and has details on what every button does. I went through and made mini diagrams for myself to make sure I understood exactly what each aspect was and how the final sound is put together. This was particularly exciting because I actually was able to read the diagram and knew what they were talking about which I know I would not have been able to do before taking this class.... but I digress. 


#### Coding

Now that I understood how everything was supposed to work it was time to actually do it. I started with the front end because all of the backend coding relies on the states of the front end, visual, elements to make decisions. I decided to use range sliders instead of plugins for knobs because I found the knob implementations on the computer difficult to use and not very accurate--they wouldn't turn when I tried to get them to or would turn too far. In using range sliders I could clearly specify step increments and add tickmarks to show the user what they were selecting in the same way the physical minimoog does. For waveform selection I used a dropdown menu instead of a range slider to transition from a knob because its not a range selection but instead concrete points, so I don't care about the integer values they map to. The final element to implement was switches which I used a formatted checkbox to implement. I had fun with the formatting here because I kept the colors of the switches consistent with the minimoog -- since they represent what the switch is used for -- except for the noise type switch which I made to switch between light grey and pink to show if it's on white noise or pink noise. As for shading I had them swap between a transparent version of the color and a fully saturated version of the color when off and on if the switch was purely a power switch to signal that. Conversely switches that change input do not switch between transparent or not because they are changing between two equivalent options.

Moral of the story is html is an aggravating language and no one should build an entire website out of html. Just trying to read through all of the lines of code I made even though I made distinct classes and commented my code is exhasting. It got to the point where I made a separate css styleguide because I needed to clean out the html index file as much as possible. 

Anyways, I finally got the front end all configured and organized and looking pretty so it was time to move on to the back end. I went back to my favorite diagram in the minimoog manual and went through to implement everything the way I saw it. Did I end up completing everything I had originally intended... no... However, I did learn a lot more about how sounds are created electronically and how to use different oscillators, gains, filters, etc. I can't believe people are really making music by keeping track of so many small details in changing a synthesizer. But basically, the frequencies mapped to specific keys are tuned and then sent through 0-3 oscilaltors depending on how many are turned on. The first oscillator is a pure sound, the second one can be a modulated version of the pure sound, and the third can be that as well, OR it can be used as a modulation source if it is disconnected and turned on elsewhere. Those oscillators are then synthesized together in the mixer potentially along with pink or white noise which is then all sent through the moog ladder filter. It's not entirely clear to me what kind of filter this is (everywhere I found online just says its innovative to moog), but it can filter based on a specified ADSR envelope, a specified cutoff frequency, be used to connect to modulation from any of the optional sources, or be connected back to emphasis resonance from before. Finally the sound is put into the overall sound envelope and passed to the output.